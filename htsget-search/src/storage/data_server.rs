//! The following module provides an implementation of [UrlFormatter] for https, and the server
//! code which responds to formatted urls.
//!
//! This is the code that replies to the url tickets generated by [HtsGet], in the case of [LocalStorage].
//!

use std::net::{AddrParseError, SocketAddr};
use std::path::Path;
use std::pin::Pin;
use std::sync::Arc;

use axum::Router;
use futures_util::future::poll_fn;
use hyper::server::accept::Accept;
use hyper::server::conn::{AddrIncoming, Http};
use tokio::net::TcpListener;
use tokio_rustls::TlsAcceptor;
use tower::MakeService;
use tower_http::services::ServeDir;
use tower_http::trace::TraceLayer;
use tracing::instrument;
use tracing::{info, trace};

use htsget_config::config::cors::CorsConfig;
use htsget_config::config::DataServerConfig;
use htsget_config::tls::TlsServerConfig;
use htsget_config::types::Scheme;

use crate::storage::configure_cors;
use crate::storage::StorageError::{IoError, ServerError};

use super::{Result, StorageError};

/// The maximum amount of time a CORS request can be cached for.
pub const CORS_MAX_AGE: u64 = 86400;

/// Ticket server url formatter.
#[derive(Debug, Clone)]
pub struct BindDataServer {
  addr: SocketAddr,
  cert_key_pair: Option<TlsServerConfig>,
  scheme: Scheme,
  cors: CorsConfig,
  serve_at: String,
}

impl BindDataServer {
  pub fn new(addr: SocketAddr, cors: CorsConfig, serve_at: String) -> Self {
    Self {
      addr,
      cert_key_pair: None,
      scheme: Scheme::Http,
      cors,
      serve_at,
    }
  }

  pub fn new_with_tls(
    addr: SocketAddr,
    cors: CorsConfig,
    tls: TlsServerConfig,
    serve_at: String,
  ) -> Self {
    Self {
      addr,
      cert_key_pair: Some(tls),
      scheme: Scheme::Https,
      cors,
      serve_at,
    }
  }

  /// Get the scheme this formatter is using - either HTTP or HTTPS.
  pub fn get_scheme(&self) -> &Scheme {
    &self.scheme
  }

  /// Eagerly bind the address by returning a `DataServer`. This function also updates the
  /// address to the actual bound address, and replaces the cert_key_pair with None.
  pub async fn bind_data_server(&mut self) -> Result<DataServer> {
    let server = DataServer::bind_addr(
      self.addr,
      &self.serve_at,
      self.cert_key_pair.take(),
      self.cors.clone(),
    )
    .await?;
    self.addr = server.local_addr();
    Ok(server)
  }

  /// Get the [SocketAddr] of this formatter.
  pub fn get_addr(&self) -> SocketAddr {
    self.addr
  }
}

impl From<DataServerConfig> for BindDataServer {
  /// Returns a ticket server with TLS enabled if the tls config is not None or without TLS enabled
  /// if it is None.
  fn from(config: DataServerConfig) -> Self {
    let addr = config.addr();
    let cors = config.cors().clone();
    let serve_at = config.serve_at().to_string();

    match config.into_tls() {
      None => Self::new(addr, cors, serve_at),
      Some(tls) => Self::new_with_tls(addr, cors, tls, serve_at),
    }
  }
}

impl From<AddrParseError> for StorageError {
  fn from(err: AddrParseError) -> Self {
    StorageError::InvalidAddress(err)
  }
}

/// The local storage static http server.
#[derive(Debug)]
pub struct DataServer {
  listener: AddrIncoming,
  serve_at: String,
  cert_key_pair: Option<TlsServerConfig>,
  cors: CorsConfig,
}

impl DataServer {
  /// Eagerly bind the the address for use with the server, returning any errors.
  #[instrument(skip(serve_at, cert_key_pair))]
  pub async fn bind_addr(
    addr: SocketAddr,
    serve_at: impl Into<String>,
    cert_key_pair: Option<TlsServerConfig>,
    cors: CorsConfig,
  ) -> Result<DataServer> {
    let listener = TcpListener::bind(addr)
      .await
      .map_err(|err| IoError("binding data server addr".to_string(), err))?;
    let listener = AddrIncoming::from_listener(listener)?;

    info!(address = ?listener.local_addr(), "data server address bound to");
    Ok(Self {
      listener,
      serve_at: serve_at.into(),
      cert_key_pair,
      cors,
    })
  }

  /// Run the actual server, using the provided path, key and certificate.
  #[instrument(level = "trace", skip_all)]
  pub async fn serve<P: AsRef<Path>>(mut self, path: P) -> Result<()> {
    let mut app = Router::new()
      .nest_service(&self.serve_at, ServeDir::new(path))
      .layer(configure_cors(self.cors)?)
      .layer(TraceLayer::new_for_http())
      .into_make_service_with_connect_info::<SocketAddr>();

    // TODO write using new axum functions.
    match self.cert_key_pair {
      None => axum::Server::builder(self.listener)
        .serve(app)
        .await
        .map_err(|err| ServerError(err.to_string())),
      Some(tls) => {
        let acceptor = TlsAcceptor::from(Arc::new(tls.into_inner()));

        loop {
          let stream = poll_fn(|cx| Pin::new(&mut self.listener).poll_accept(cx))
            .await
            .ok_or_else(|| ServerError("poll accept failed".to_string()))?
            .map_err(|err| ServerError(err.to_string()))?;
          let acceptor = acceptor.clone();

          let app = app
            .make_service(&stream)
            .await
            .map_err(|err| ServerError(err.to_string()))?;

          trace!(stream = ?stream, "accepting stream");
          tokio::spawn(async move {
            if let Ok(stream) = acceptor.accept(stream).await {
              let _ = Http::new().serve_connection(stream, app).await;
            }
          });
        }
      }
    }
  }

  /// Get the local address the server has bound to.
  pub fn local_addr(&self) -> SocketAddr {
    self.listener.local_addr()
  }
}

impl From<hyper::Error> for StorageError {
  fn from(error: hyper::Error) -> Self {
    ServerError(error.to_string())
  }
}

#[cfg(test)]
mod tests {
  use std::str::FromStr;

  use async_trait::async_trait;
  use http::header::HeaderName;
  use http::{HeaderMap, HeaderValue, Method};
  use reqwest::{Client, ClientBuilder, RequestBuilder};
  use tempfile::tempdir;

  use htsget_test::http::cors::{test_cors_preflight_request_uri, test_cors_simple_request_uri};
  use htsget_test::http::{
    config_with_tls, default_cors_config, default_test_config, Header, Response as TestResponse,
    TestRequest, TestServer,
  };

  use crate::storage::local::tests::create_local_test_files;
  use crate::Config;

  use super::*;

  struct DataTestServer {
    config: Config,
  }

  struct DataTestRequest {
    client: Client,
    headers: HeaderMap,
    payload: String,
    method: Method,
    uri: String,
  }

  impl TestRequest for DataTestRequest {
    fn insert_header(mut self, header: Header<impl Into<String>>) -> Self {
      self.headers.insert(
        HeaderName::from_str(&header.name.into()).unwrap(),
        HeaderValue::from_str(&header.value.into()).unwrap(),
      );
      self
    }

    fn set_payload(mut self, payload: impl Into<String>) -> Self {
      self.payload = payload.into();
      self
    }

    fn uri(mut self, uri: impl Into<String>) -> Self {
      self.uri = uri.into().parse().unwrap();
      self
    }

    fn method(mut self, method: impl Into<String>) -> Self {
      self.method = method.into().parse().unwrap();
      self
    }
  }

  impl DataTestRequest {
    fn build(self) -> RequestBuilder {
      self
        .client
        .request(self.method, self.uri)
        .headers(self.headers)
        .body(self.payload)
    }
  }

  impl Default for DataTestRequest {
    fn default() -> Self {
      Self {
        client: ClientBuilder::new()
          .danger_accept_invalid_certs(true)
          .use_rustls_tls()
          .build()
          .unwrap(),
        headers: HeaderMap::default(),
        payload: "".to_string(),
        method: Method::GET,
        uri: "".to_string(),
      }
    }
  }

  impl Default for DataTestServer {
    fn default() -> Self {
      Self {
        config: default_test_config(),
      }
    }
  }

  #[async_trait(?Send)]
  impl TestServer<DataTestRequest> for DataTestServer {
    async fn get_expected_path(&self) -> String {
      "".to_string()
    }

    fn get_config(&self) -> &Config {
      &self.config
    }

    fn get_request(&self) -> DataTestRequest {
      DataTestRequest::default()
    }

    async fn test_server(&self, request: DataTestRequest, expected_path: String) -> TestResponse {
      let response = request.build().send().await.unwrap();
      let status: u16 = response.status().into();
      let headers = response.headers().clone();
      let bytes = response.bytes().await.unwrap().to_vec();

      TestResponse::new(status, headers, bytes, expected_path)
    }
  }

  #[tokio::test]
  async fn test_http_server() {
    let (_, base_path) = create_local_test_files().await;

    test_server("http", None, base_path.path().to_path_buf()).await;
  }

  #[tokio::test]
  async fn test_tls_server() {
    let (_, base_path) = create_local_test_files().await;
    let config = config_with_tls(base_path.path()).data_server().clone();
    let server_config = config.into_tls().unwrap();

    test_server("https", Some(server_config), base_path.path().to_path_buf()).await;
  }

  #[test]
  fn http_scheme() {
    let formatter = BindDataServer::new(
      "127.0.0.1:8080".parse().unwrap(),
      CorsConfig::default(),
      "/data".to_string(),
    );
    assert_eq!(formatter.get_scheme(), &Scheme::Http);
  }

  #[test]
  fn https_scheme() {
    assert_eq!(tls_formatter().get_scheme(), &Scheme::Https);
  }

  #[tokio::test]
  async fn get_addr_local_addr() {
    let mut formatter = BindDataServer::new(
      "127.0.0.1:0".parse().unwrap(),
      CorsConfig::default(),
      "/data".to_string(),
    );
    let server = formatter.bind_data_server().await.unwrap();
    assert_eq!(formatter.get_addr(), server.local_addr());
  }

  #[tokio::test]
  async fn cors_simple_response() {
    let (_, base_path) = create_local_test_files().await;

    let port = start_server(None, base_path.path().to_path_buf()).await;

    test_cors_simple_request_uri(
      &DataTestServer::default(),
      &format!("http://localhost:{port}/data/key1"),
    )
    .await;
  }

  #[tokio::test]
  async fn cors_options_response() {
    let (_, base_path) = create_local_test_files().await;

    let port = start_server(None, base_path.path().to_path_buf()).await;

    test_cors_preflight_request_uri(
      &DataTestServer::default(),
      &format!("http://localhost:{port}/data/key1"),
    )
    .await;
  }

  fn tls_formatter() -> BindDataServer {
    let tmp_dir = tempdir().unwrap();
    let config = config_with_tls(tmp_dir.path()).data_server().clone();
    let server_config = config.into_tls().unwrap();

    BindDataServer::new_with_tls(
      "127.0.0.1:8080".parse().unwrap(),
      CorsConfig::default(),
      server_config,
      "/data".to_string(),
    )
  }

  async fn start_server<P>(cert_key_pair: Option<TlsServerConfig>, path: P) -> u16
  where
    P: AsRef<Path> + Send + 'static,
  {
    let addr = SocketAddr::from_str(&format!("{}:{}", "127.0.0.1", "0")).unwrap();
    let server = DataServer::bind_addr(addr, "/data", cert_key_pair, default_cors_config())
      .await
      .unwrap();
    let port = server.local_addr().port();
    tokio::spawn(async move { server.serve(path).await.unwrap() });

    port
  }

  async fn test_server<P>(scheme: &str, cert_key_pair: Option<TlsServerConfig>, path: P)
  where
    P: AsRef<Path> + Send + 'static,
  {
    let port = start_server(cert_key_pair, path).await;

    let test_server = DataTestServer::default();
    let request = test_server
      .get_request()
      .method(Method::GET.to_string())
      .uri(format!("{scheme}://localhost:{port}/data/key1"));
    let response = test_server.test_server(request, "".to_string()).await;

    assert!(response.is_success());
    assert_eq!(response.body, b"value1");
  }
}
