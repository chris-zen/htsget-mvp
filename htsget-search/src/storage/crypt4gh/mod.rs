use bytes::{Buf, Bytes};
use crypt4gh::Keys;
use futures::Stream;
use std::future::Future;
use std::{cmp, io};
use tokio::io::AsyncBufRead;
use tokio::io::AsyncRead;

pub mod decoder;
pub mod decrypter;
pub mod error;
pub mod reader;

/// A wrapper around a vec of bytes that represent a sender public key.
#[derive(Debug, Clone)]
pub struct SenderPublicKey {
  bytes: Vec<u8>,
}

impl SenderPublicKey {
  /// Create a new sender public key from bytes.
  pub fn new(bytes: Vec<u8>) -> Self {
    Self { bytes }
  }

  /// Get the inner bytes.
  pub fn into_inner(self) -> Vec<u8> {
    self.bytes
  }
}

/// A wrapper around a vec of bytes that represents plain text bytes.
#[derive(Debug, Clone)]
pub struct PlainTextBytes(Bytes);

impl PlainTextBytes {
  /// Create new plain text bytes from bytes.
  pub fn new(bytes: Bytes) -> Self {
    Self(bytes)
  }

  /// Get the inner bytes.
  pub fn into_inner(self) -> Bytes {
    self.0
  }
}

#[cfg(test)]
pub(crate) mod tests {
  use crypt4gh::header::deconstruct_header_body;
  use crypt4gh::keys::{get_private_key, get_public_key};
  use std::io;

  use super::*;
  use hex_literal::hex;
  use htsget_test::http_tests::get_test_path;

  const PLAINTEXT: &[u8] = &[
    0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5, 0xcf, 0x14, 0x13, 0x16, 0xeb, 0xeb, 0x0c, 0x7b,
    0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4, 0x4b, 0x66, 0x84, 0x9b, 0x64, 0x24, 0x4f, 0xfc,
    0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a, 0x1a, 0xc7, 0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29,
    0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4, 0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31,
    0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46, 0xf0, 0x6d, 0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57,
    0xe2, 0xf6, 0x55, 0x6a, 0xd6, 0xb1, 0x31, 0x8a, 0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde,
    0x04, 0x89, 0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd, 0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e, 0x52,
    0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40, 0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38, 0x48, 0x64,
    0x5e, 0x07, 0x05,
  ];

  const CIPHERTEXT: &[u8] = &[
    0x0c, 0x9a, 0x1b, 0xfa, 0x07, 0x05, 0x85, 0xae, 0xb8, 0xcb, 0xdd, 0x80, 0xf3, 0x5d, 0xb1, 0x55,
    0x8b, 0x14, 0xa9, 0xa2, 0x11, 0xc5, 0x28, 0x18, 0xc0, 0x78, 0x69, 0x90, 0xda, 0x61, 0x84, 0x63,
    0xdb, 0x80, 0x9d, 0x3a, 0x93, 0x94, 0x76, 0x48, 0xd1, 0x4b, 0x9f, 0xa9, 0x17, 0x9a, 0xf7, 0x8f,
    0x20, 0x33, 0xef, 0x0f, 0x2a, 0xe5, 0x8a, 0xcf, 0x7f, 0x4b, 0x3d, 0x5e, 0x8e, 0x05, 0x9e, 0x96,
    0x31, 0xe3, 0xc8, 0x86, 0x7d, 0x94, 0x3e, 0x90, 0x79, 0xfa, 0x88, 0x87, 0xed, 0x01, 0x3c, 0xb6,
    0xba, 0x0a, 0x1a, 0xed, 0xcb, 0x79, 0x5c, 0x65, 0x6b, 0xfa, 0xe5, 0xb7, 0xe4, 0xf8, 0x65, 0x60,
    0x5d, 0xe3, 0x93, 0x12, 0x4b, 0x63, 0x18, 0xe2, 0x61, 0xc3, 0x94, 0x88, 0xf3, 0x46, 0xfc, 0xa9,
    0xf9, 0xe1, 0x9d, 0x34, 0xb3, 0xaa, 0xb0, 0x56, 0x44, 0x3c, 0xa5, 0xdc, 0xe2, 0x9a, 0xf1, 0xba,
    0xf5, 0xaf, 0xd2, 0x16, 0x34, 0x36, 0xd8, 0x65, 0xc7, 0x34, 0xc5, 0x79, 0x4c, 0x4e, 0x7e, 0xbe,
    0x88, 0xe3, 0xdf,
  ];

  // Alice's keypair
  const ALICE_SECRET_KEY: [u8; 32] =
    hex!("68f208412d8dd5db9d0c6d18512e86f0ec75665ab841372d57b042b27ef89d4c");
  const ALICE_PUBLIC_KEY: [u8; 32] =
    hex!("ac3a70ba35df3c3fae427a7c72021d68f2c1e044040b75f17313c0c8b5d4241d");

  // Bob's keypair
  const BOB_SECRET_KEY: [u8; 32] =
    hex!("b581fb5ae182a16f603f39270d4e3b95bc008310b727a11dd4e784a0044d461b");
  const BOB_PUBLIC_KEY: [u8; 32] =
    hex!("e8980c86e032f1eb2975052e8d65bddd15c3b59641174ec9678a53789d92c754");

  // TODO: Write tests for different levels of Decrytor/DataBlocks/etc...

  #[tokio::test]
  async fn crypt4gh_encrypt() {
    let keys = Keys {
      method: 0,
      privkey: Vec::from(ALICE_SECRET_KEY),
      recipient_pubkey: Vec::from(BOB_PUBLIC_KEY),
    };
    // let ciphertext = DataBlockStreamDecryptor::new(
    //   PLAINTEXT,
    //   vec![keys],
    //   Some(SenderPublicKey {
    //     bytes: Vec::from(BOB_PUBLIC_KEY),
    //   }),
    // )
    // .encrypt();
    //
    // assert_eq!(CIPHERTEXT, ciphertext);
  }

  #[tokio::test]
  async fn crypt4gh_decrypt() -> io::Result<()> {
    todo!()
    // let data_blocks = ...;

    // let reader = BgzfReader::new(Crypt4ghReader::new(data_blocks));

    // reader.read_block();

    // let plaintext = DataBlockStreamDecryptor::new().decrypter();
    //
    // assert_eq!(PLAINTEXT, plaintext);
  }

  /// Returns the private keys of the recipient and the senders public key from the context of decryption.
  pub(crate) async fn get_keys() -> (Keys, Vec<u8>) {
    let recipient_private_key = get_private_key(&get_test_path("crypt4gh/keys/bob.sec"), || {
      Ok("".to_string())
    })
    .unwrap();
    let sender_public_key = get_public_key(&get_test_path("crypt4gh/keys/alice.pub")).unwrap();

    (
      Keys {
        method: 0,
        privkey: recipient_private_key,
        recipient_pubkey: sender_public_key.clone(),
      },
      sender_public_key,
    )
  }
}
