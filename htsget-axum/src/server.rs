//! The following module provides an implementation of [UrlFormatter] for https, and the server
//! code which responds to formatted urls.
//!
//! This is the code that replies to the url tickets generated by [HtsGet], in the case of [LocalStorage].
//!

use std::net::SocketAddr;
use std::path::Path;
use std::sync::Arc;
use std::time::Duration;

use axum::extract::Request;
use axum::routing::get;
use axum::Router;
use http::HeaderValue;
use hyper::body::Incoming;
use hyper::service::service_fn;
use hyper_util::rt::{TokioExecutor, TokioIo};
use hyper_util::server::conn::auto::Builder;
use tokio::net::TcpListener;
use tokio_rustls::TlsAcceptor;
use tower::Service;
use tower::ServiceBuilder;
use tower_http::cors::{AllowHeaders, AllowMethods, AllowOrigin, CorsLayer, ExposeHeaders};
use tower_http::services::ServeDir;
use tower_http::trace::TraceLayer;
use tracing::{error, warn};
use tracing::{info, trace};

use htsget_config::config::cors::CorsConfig;
use htsget_config::config::{DataServerConfig, ServiceInfo, TicketServerConfig};
use htsget_config::tls::TlsServerConfig;
use htsget_config::types::Scheme;
use htsget_search::HtsGet;

use crate::error::Error::ServerError;
use crate::error::Result;
use crate::handlers::{get, post, reads_service_info, variants_service_info};

/// Represents the axum app state.
#[derive(Debug, Clone)]
pub struct AppState<H: HtsGet> {
  pub htsget: Arc<H>,
  pub service_info: ServiceInfo,
}

/// Configure cors, settings allowed methods, max age, allowed origins, and if credentials
/// are supported.
pub fn configure_cors(cors: CorsConfig) -> CorsLayer {
  let mut cors_layer = CorsLayer::new();

  cors_layer = cors.allow_origins().apply_any(
    |cors_layer| cors_layer.allow_origin(AllowOrigin::any()),
    cors_layer,
  );
  cors_layer = cors.allow_origins().apply_mirror(
    |cors_layer| cors_layer.allow_origin(AllowOrigin::mirror_request()),
    cors_layer,
  );
  cors_layer = cors.allow_origins().apply_list(
    |cors_layer, origins| {
      cors_layer.allow_origin(
        origins
          .iter()
          .map(|header| header.clone().into_inner())
          .collect::<Vec<HeaderValue>>(),
      )
    },
    cors_layer,
  );

  cors_layer = cors.allow_headers().apply_any(
    |cors_layer| cors_layer.allow_headers(AllowHeaders::mirror_request()),
    cors_layer,
  );
  cors_layer = cors.allow_headers().apply_list(
    |cors_layer, headers| cors_layer.allow_headers(headers.clone()),
    cors_layer,
  );

  cors_layer = cors.allow_methods().apply_any(
    |cors_layer| cors_layer.allow_methods(AllowMethods::mirror_request()),
    cors_layer,
  );
  cors_layer = cors.allow_methods().apply_list(
    |cors_layer, methods| cors_layer.allow_methods(methods.clone()),
    cors_layer,
  );

  cors_layer = cors.expose_headers().apply_any(
    |cors_layer| cors_layer.expose_headers(ExposeHeaders::any()),
    cors_layer,
  );
  cors_layer = cors.expose_headers().apply_list(
    |cors_layer, headers| cors_layer.expose_headers(headers.clone()),
    cors_layer,
  );

  cors_layer
    .allow_credentials(cors.allow_credentials())
    .max_age(Duration::from_secs(cors.max_age() as u64))
}

/// An axum server which should bind an address.
#[derive(Debug, Clone)]
pub struct BindServer {
  addr: SocketAddr,
  cert_key_pair: Option<TlsServerConfig>,
  scheme: Scheme,
  cors: CorsConfig,
}

impl BindServer {
  pub fn new(addr: SocketAddr, cors: CorsConfig) -> Self {
    Self {
      addr,
      cert_key_pair: None,
      scheme: Scheme::Http,
      cors,
    }
  }

  pub fn new_with_tls(addr: SocketAddr, cors: CorsConfig, tls: TlsServerConfig) -> Self {
    Self {
      addr,
      cert_key_pair: Some(tls),
      scheme: Scheme::Https,
      cors,
    }
  }

  /// Get the scheme this formatter is using - either HTTP or HTTPS.
  pub fn get_scheme(&self) -> &Scheme {
    &self.scheme
  }

  /// Eagerly bind the address by returning a `Server`. This function also updates the
  /// address to the actual bound address, and replaces the cert_key_pair with None.
  pub async fn bind_server(&mut self) -> Result<Server> {
    let server = Server::bind_addr(self.addr, self.cert_key_pair.take()).await?;
    self.addr = server.local_addr()?;

    Ok(server)
  }

  /// Eagerly bind the address by returning a `DataServer`.
  pub async fn bind_data_server(&mut self, serve_at: String) -> Result<DataServer> {
    let server = self.bind_server().await?;

    Ok(DataServer::new(server, serve_at, self.cors.clone()))
  }

  /// Eagerly bind the address by returning a `TicketServer`.
  pub async fn bind_ticket_server<H>(
    &mut self,
    htsget: H,
    service_info: ServiceInfo,
  ) -> Result<TicketServer<H>>
  where
    H: HtsGet + Clone + Send + Sync + 'static,
  {
    let server = self.bind_server().await?;

    Ok(TicketServer::new(
      server,
      htsget,
      service_info,
      self.cors.clone(),
    ))
  }

  /// Get the [SocketAddr] of this formatter.
  pub fn get_addr(&self) -> SocketAddr {
    self.addr
  }
}

impl From<DataServerConfig> for BindServer {
  /// Returns a data server with TLS enabled if the tls config is not None or without TLS enabled
  /// if it is None.
  fn from(config: DataServerConfig) -> Self {
    let addr = config.addr();
    let cors = config.cors().clone();

    match config.into_tls() {
      None => Self::new(addr, cors),
      Some(tls) => Self::new_with_tls(addr, cors, tls),
    }
  }
}

impl From<TicketServerConfig> for BindServer {
  /// Returns a ticket server with TLS enabled if the tls config is not None or without TLS enabled
  /// if it is None.
  fn from(config: TicketServerConfig) -> Self {
    let addr = config.addr();
    let cors = config.cors().clone();

    match config.into_tls() {
      None => Self::new(addr, cors),
      Some(tls) => Self::new_with_tls(addr, cors, tls),
    }
  }
}

/// An Axum server.
#[derive(Debug)]
pub struct Server {
  listener: TcpListener,
  cert_key_pair: Option<TlsServerConfig>,
}

impl Server {
  /// Eagerly bind the address for use with the server, returning any errors.
  pub async fn bind_addr(
    addr: SocketAddr,
    cert_key_pair: Option<TlsServerConfig>,
  ) -> Result<Server> {
    let listener = TcpListener::bind(addr).await?;

    info!(address = ?listener.local_addr(), "data server address bound to");
    Ok(Self {
      listener,
      cert_key_pair,
    })
  }

  /// Run the actual server, using the router, key and certificate.
  pub async fn serve(self, app: Router) -> Result<()> {
    match self.cert_key_pair {
      None => axum::serve(self.listener, app)
        .await
        .map_err(|err| ServerError(err.to_string())),
      Some(tls) => {
        let tls_acceptor = TlsAcceptor::from(Arc::new(tls.into_inner()));

        loop {
          let tower_service = app.clone();
          let tls_acceptor = tls_acceptor.clone();

          trace!("accepting connection");
          let (cnx, addr) = self.listener.accept().await.unwrap();

          tokio::spawn(async move {
            let Ok(stream) = tls_acceptor.accept(cnx).await else {
              error!("error during tls handshake connection from {}", addr);
              return;
            };

            let stream = TokioIo::new(stream);
            let hyper_service =
              service_fn(move |request: Request<Incoming>| tower_service.clone().call(request));

            let ret = Builder::new(TokioExecutor::new())
              .serve_connection_with_upgrades(stream, hyper_service)
              .await;

            if let Err(err) = ret {
              warn!("error serving connection from {}: {}", addr, err);
            }
          });
        }
      }
    }
  }

  /// Get the local address the server has bound to.
  pub fn local_addr(&self) -> Result<SocketAddr> {
    Ok(self.listener.local_addr()?)
  }
}

/// An data block server.
#[derive(Debug)]
pub struct DataServer {
  server: Server,
  serve_at: String,
  cors: CorsConfig,
}

impl DataServer {
  /// Create a new data server.
  pub fn new(server: Server, serve_at: String, cors: CorsConfig) -> Self {
    Self {
      server,
      serve_at,
      cors,
    }
  }

  /// Run the data server, using the provided path, key and certificate.
  pub async fn serve<P: AsRef<Path>>(self, path: P) -> Result<()> {
    self
      .server
      .serve(Self::router(self.cors, &self.serve_at, path))
      .await
  }

  /// Create the router for the data server.
  pub fn router<P: AsRef<Path>>(cors: CorsConfig, serve_at: &str, path: P) -> Router {
    Router::new()
      .nest_service(serve_at, ServeDir::new(path))
      .layer(configure_cors(cors))
      .layer(TraceLayer::new_for_http())
  }

  /// Get the local address the server has bound to.
  pub fn local_addr(&self) -> Result<SocketAddr> {
    self.server.local_addr()
  }
}

/// An data block server.
#[derive(Debug)]
pub struct TicketServer<H> {
  server: Server,
  htsget: H,
  service_info: ServiceInfo,
  cors: CorsConfig,
}

impl<H> TicketServer<H>
where
  H: HtsGet + Clone + Send + Sync + 'static,
{
  /// Create a new ticket server.
  pub fn new(server: Server, htsget: H, service_info: ServiceInfo, cors: CorsConfig) -> Self {
    Self {
      server,
      htsget,
      service_info,
      cors,
    }
  }

  /// Run the data server, using the key and certificate.
  pub async fn serve(self) -> Result<()> {
    self
      .server
      .serve(Self::router(self.htsget, self.service_info, self.cors))
      .await
  }

  /// Create the router for the ticket server.
  pub fn router(htsget: H, service_info: ServiceInfo, cors: CorsConfig) -> Router {
    Router::default()
      .route(
        "/reads/service-info",
        get(reads_service_info::<H>).post(reads_service_info::<H>),
      )
      .route("/reads/*id", get(get::reads).post(post::reads))
      .route(
        "/reads/service-info",
        get(variants_service_info::<H>).post(variants_service_info::<H>),
      )
      .route("/reads/*id", get(get::variants).post(post::variants))
      .layer(
        ServiceBuilder::new()
          .layer(TraceLayer::new_for_http())
          .layer(configure_cors(cors)),
      )
      .with_state(AppState {
        htsget: Arc::new(htsget),
        service_info,
      })
  }

  /// Get the local address the server has bound to.
  pub fn local_addr(&self) -> Result<SocketAddr> {
    self.server.local_addr()
  }
}

#[cfg(test)]
mod tests {
  use std::str::FromStr;

  use async_trait::async_trait;
  use http::header::HeaderName;
  use http::{HeaderMap, HeaderValue, Method};
  use reqwest::{Client, ClientBuilder, RequestBuilder};
  use tempfile::{tempdir, TempDir};
  use tokio::fs::{create_dir, File};
  use tokio::io::AsyncWriteExt;

  use htsget_config::config::Config;
  use htsget_test::http::cors::{test_cors_preflight_request_uri, test_cors_simple_request_uri};
  use htsget_test::http::{
    config_with_tls, default_cors_config, default_test_config, Header, Response as TestResponse,
    TestRequest, TestServer,
  };

  use super::*;

  struct DataTestServer {
    config: Config,
  }

  struct DataTestRequest {
    client: Client,
    headers: HeaderMap,
    payload: String,
    method: Method,
    uri: String,
  }

  impl TestRequest for DataTestRequest {
    fn insert_header(mut self, header: Header<impl Into<String>>) -> Self {
      self.headers.insert(
        HeaderName::from_str(&header.name.into()).unwrap(),
        HeaderValue::from_str(&header.value.into()).unwrap(),
      );
      self
    }

    fn set_payload(mut self, payload: impl Into<String>) -> Self {
      self.payload = payload.into();
      self
    }

    fn uri(mut self, uri: impl Into<String>) -> Self {
      self.uri = uri.into().parse().unwrap();
      self
    }

    fn method(mut self, method: impl Into<String>) -> Self {
      self.method = method.into().parse().unwrap();
      self
    }
  }

  impl DataTestRequest {
    fn build(self) -> RequestBuilder {
      self
        .client
        .request(self.method, self.uri)
        .headers(self.headers)
        .body(self.payload)
    }
  }

  impl Default for DataTestRequest {
    fn default() -> Self {
      Self {
        client: ClientBuilder::new()
          .danger_accept_invalid_certs(true)
          .use_rustls_tls()
          .build()
          .unwrap(),
        headers: HeaderMap::default(),
        payload: "".to_string(),
        method: Method::GET,
        uri: "".to_string(),
      }
    }
  }

  impl Default for DataTestServer {
    fn default() -> Self {
      Self {
        config: default_test_config(),
      }
    }
  }

  #[async_trait(?Send)]
  impl TestServer<DataTestRequest> for DataTestServer {
    async fn get_expected_path(&self) -> String {
      "".to_string()
    }

    fn get_config(&self) -> &Config {
      &self.config
    }

    fn get_request(&self) -> DataTestRequest {
      DataTestRequest::default()
    }

    async fn test_server(&self, request: DataTestRequest, expected_path: String) -> TestResponse {
      let response = request.build().send().await.unwrap();
      let status: u16 = response.status().into();
      let headers = response.headers().clone();
      let bytes = response.bytes().await.unwrap().to_vec();

      TestResponse::new(status, headers, bytes, expected_path)
    }
  }

  #[tokio::test]
  async fn test_http_server() {
    let (_, base_path) = create_local_test_files().await;

    test_server("http", None, base_path.path().to_path_buf()).await;
  }

  #[tokio::test]
  async fn test_tls_server() {
    let (_, base_path) = create_local_test_files().await;
    let config = config_with_tls(base_path.path()).data_server().clone();
    let server_config = config.into_tls().unwrap();

    test_server("https", Some(server_config), base_path.path().to_path_buf()).await;
  }

  #[test]
  fn http_scheme() {
    let formatter = BindServer::new("127.0.0.1:8080".parse().unwrap(), CorsConfig::default());
    assert_eq!(formatter.get_scheme(), &Scheme::Http);
  }

  #[test]
  fn https_scheme() {
    assert_eq!(tls_formatter().get_scheme(), &Scheme::Https);
  }

  #[tokio::test]
  async fn get_addr_local_addr() {
    let mut formatter = BindServer::new("127.0.0.1:0".parse().unwrap(), CorsConfig::default());
    let server = formatter.bind_server().await.unwrap();
    assert_eq!(formatter.get_addr(), server.local_addr().unwrap());
  }

  #[tokio::test]
  async fn cors_simple_response() {
    let (_, base_path) = create_local_test_files().await;

    let port = start_data_server(None, base_path.path().to_path_buf()).await;

    test_cors_simple_request_uri(
      &DataTestServer::default(),
      &format!("http://localhost:{port}/data/key1"),
    )
    .await;
  }

  #[tokio::test]
  async fn cors_options_response() {
    let (_, base_path) = create_local_test_files().await;

    let port = start_data_server(None, base_path.path().to_path_buf()).await;

    test_cors_preflight_request_uri(
      &DataTestServer::default(),
      &format!("http://localhost:{port}/data/key1"),
    )
    .await;
  }

  fn tls_formatter() -> BindServer {
    let tmp_dir = tempdir().unwrap();
    let config = config_with_tls(tmp_dir.path()).data_server().clone();
    let server_config = config.into_tls().unwrap();

    BindServer::new_with_tls(
      "127.0.0.1:8080".parse().unwrap(),
      CorsConfig::default(),
      server_config,
    )
  }

  async fn start_data_server<P>(cert_key_pair: Option<TlsServerConfig>, path: P) -> u16
  where
    P: AsRef<Path> + Send + 'static,
  {
    let addr = SocketAddr::from_str(&format!("{}:{}", "127.0.0.1", "0")).unwrap();
    let server = Server::bind_addr(addr, cert_key_pair).await.unwrap();
    let port = server.local_addr().unwrap().port();

    let data_server = DataServer::new(server, "/data".to_string(), default_cors_config());
    tokio::spawn(async move { data_server.serve(path).await.unwrap() });

    port
  }

  async fn test_server<P>(scheme: &str, cert_key_pair: Option<TlsServerConfig>, path: P)
  where
    P: AsRef<Path> + Send + 'static,
  {
    let port = start_data_server(cert_key_pair, path).await;

    let test_server = DataTestServer::default();
    let request = test_server
      .get_request()
      .method(Method::GET.to_string())
      .uri(format!("{scheme}://localhost:{port}/data/key1"));
    let response = test_server.test_server(request, "".to_string()).await;

    assert!(response.is_success());
    assert_eq!(response.body, b"value1");
  }

  pub(crate) async fn create_local_test_files() -> (String, TempDir) {
    let base_path = TempDir::new().unwrap();

    let folder_name = "folder";
    let key1 = "key1";
    let value1 = b"value1";
    let key2 = "key2";
    let value2 = b"value2";
    File::create(base_path.path().join(key1))
      .await
      .unwrap()
      .write_all(value1)
      .await
      .unwrap();
    create_dir(base_path.path().join(folder_name))
      .await
      .unwrap();
    File::create(base_path.path().join(folder_name).join(key2))
      .await
      .unwrap()
      .write_all(value2)
      .await
      .unwrap();

    (folder_name.to_string(), base_path)
  }
}
